# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rds_conti_radar_object_list_msgs/RadarObjectList.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rds_conti_radar_object_list_msgs.msg

class RadarObjectList(genpy.Message):
  _md5sum = "7f981a9cd2dc8a68e05581fae97c445d"
  _type = "rds_conti_radar_object_list_msgs/RadarObjectList"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """SensorMsgHeader Header

float32 CurrentYawAngle             #current mounting yaw angle [rad], range -3.14159;3.14159 
float32 EgoVelocity                 #velocity of ego vehicle, range -150;150 [m/s]
float32 EgoYawRate                  #yaw rate of ego vehicle [rad/s], range -4;4
uint32 NofUsedObjects               #number of available objects
RadarObject[] RadarObjectArray 
uint32 ExternalSensorID             #Reference to the external Sensor ID
ObjProvidedKinematicStates KinematicState #indication which reference the kinematic states are refering

================================================================================
MSG: rds_conti_radar_object_list_msgs/SensorMsgHeader
#SensorMsgHeader fields
MsgHeader CommonHeader
uint32 SensorId             #sensor ID
SignalStatus SignalStatus   #status of the signals in the data packet
================================================================================
MSG: rds_conti_radar_object_list_msgs/MsgHeader
#MsgHeader fields
uint32 Seq          #sequence ID: consecutively increasing ID
Time stamp
TimeStampSource Timestamp_source
TimeStampSyncState TimeStamp_sync_state

================================================================================
MSG: rds_conti_radar_object_list_msgs/Time
#Time fields
uint32 Sec
uint32 Nsec 

================================================================================
MSG: rds_conti_radar_object_list_msgs/TimeStampSource
#MsgHeader field TimeStampSource
uint8 TIMESTAMPSOURCE_UNKNOWN_SOURCE = 0    #No information on the source at all
uint8 TIMESTAMPSOURCE_SENSOR = 1            #Timestamp is set by sensor
uint8 TIMESTAMPSOURCE_ALGO = 2              #Timestamp is set by algo

uint8 TimeStampSource 
================================================================================
MSG: rds_conti_radar_object_list_msgs/TimeStampSyncState
#MsgHeader field TimeStampSyncState
uint8 TIMESTAMPSYNCSTATE_UNKNOWN_SYNC = 0              #No information on the sync state at all
uint8 TIMESTAMPSYNCSTATE_NOT_SYNCED = 1                #timestamp is not synced at all
uint8 TIMESTAMPSYNCSTATE_SYNCED_GTC = 2                #timestamp is synced with GTC mechanism
uint8 TIMESTAMPSYNCSTATE_SYNCED_PTP = 3                #timestamp is synced with PTP mechanism
uint8 TIMESTAMPSYNCSTATE_SYNCED_REPLAY = 4             #timestamp is synced by replay mechanism

uint8 TimeStampSyncState

================================================================================
MSG: rds_conti_radar_object_list_msgs/SignalStatus
#SensorMsgHeader SignalStatus field
uint8 SIGNALSTATUS_EM_SIGSTATE_INIT = 0
uint8 SIGNALSTATUS_EM_SIGSTATE_OK = 1
uint8 SIGNALSTATUS_EM_SIGSTATE_INVALID = 2

uint8 SignalStatus
================================================================================
MSG: rds_conti_radar_object_list_msgs/RadarObject
#RadarObject fields
uint32 ObjId                #object ID
uint32 InternalId           #object ID in internal object list
float32 DistX               #x-position in Carthesian object coordiante [m], range -200;200
float32 DistY               #y-position in Carthesian object coordiante [m], range -200;200
float32 VrelX               #relative velocity in x-direction [m/s], range -400;400
float32 VrelY               #relative velocity in y-direction [m/s], range -400;400
float32 ArelX               #relative acceleration in x-direction [m/s²], range -50;50
float32 ArelY               #relative acceleration in y-direction [m/s²], range -50;50
float32 DistXStd            #standard deviation of x-position [m], range 0;30
float32 DistYStd            #standard deviation of y-position [m], range 0;30
float32 VrelXStd            #standard deviation of relative velocity in x-direction [m/s], range 0;30
float32 VrelYStd            #standard deviation of relative velocity in y-direction [m/s], range 0;30
float32 ArelXStd            #standard deviation of relative acceleration in x-direction [m/s²], range 0;30
float32 ArelYStd            #standard deviation of relative acceleration in y-direction [m/s²], range 0;30
float32 LDeltaX_left        #x-distance between reference point and bounding box (left, mid, right) [m], range -50;50
float32 LDeltaX_mid
float32 LDeltaX_right
float32 LDeltaY_left        #y-distance between reference point and bounding box (left, mid, right) [m], range -50;50
float32 LDeltaY_mid
float32 LDeltaY_right
LDeltaQual LDeltaQual
float32 RCS                 #object RCS [dBm²], range -100;100 
float32 ProbOfExistence     #probability of existance, range 0;1
uint32 LifeCycles           #number of life cycles, range 0;65534
DynamicProperty DynamicProperty
ObjState ObjState
bool[] ObjMeasuredSources     #statement about which sensor has perceived/measured an object in the current cycle (bitfield: first bit corresponds to sensor 1, etc...): is true if object is perceived by the corresponding sensor
float32 VabsX               #absolute velocity in x-direction [m/s]
float32 VabsY               #absolute velocity in y-direction [m/s]
float32 AabsX               #absolute acceleration in x-direction [m/s²], range -50;50
float32 AabsY               #absolute acceleration in y-direction [m/s²], range -50;50
float32 VabsXStd            #standard deviation of absolute velocity in x-direction [m/s], range 0;30
float32 VabsYStd            #standard deviation of absolute velocity in y-direction [m/s], range 0;30
float32 AabsXStd            #standard deviation of absolute acceleration in x-direction [m/s²], range 0;30
float32 AabsYStd            #standard deviation of absolute acceleration in y-direction [m/s²], range 0;30
float32 Orientation         #relative orientation [rad] between target and ego, CCW positive
float32 OrientationStd      #standard deviation of relative orientation [rad] between target and ego, CCW positive




================================================================================
MSG: rds_conti_radar_object_list_msgs/LDeltaQual
#RadarObject LDeltaQual field : Quality of OBB distances
uint8 LDELTAQUAL_ALL_INVALID = 0
uint8 LDELTAQUAL_LEFT_VALID =1
uint8 LDELTAQUAL_MID_VALID = 2
uint8 LDELTAQUAL_LEFT_MID_VALID = 3
uint8 LDELTAQUAL_RIGHT_VALID = 4
uint8 LDELTAQUAL_RIGHT_LEFT_VALID = 5
uint8 LDELTAQUAL_RIGHT_MID_VALID = 6
uint8 LDELTAQUAL_ALL_VALID = 7

uint8 LDeltaQual
================================================================================
MSG: rds_conti_radar_object_list_msgs/DynamicProperty
#RadarObject DynamicProperty field
uint8 DYNAMICPROPERTY_MOVING = 0
uint8 DYNAMICPROPERTY_STATIONARY = 1
uint8 DYNAMICPROPERTY_ONCOMING = 2
uint8 DYNAMICPROPERTY_UNKNOWN = 3

uint8 DynamicProperty
================================================================================
MSG: rds_conti_radar_object_list_msgs/ObjState
#Radarobject ObjState field
uint8 OBJSTATE_DELETED = 0
uint8 OBJSTATE_NEW = 1
uint8 OBJSTATE_MEASURED = 2
uint8 OBJSTATE_PREDICTED = 3

uint8 ObjState
================================================================================
MSG: rds_conti_radar_object_list_msgs/ObjProvidedKinematicStates
#Object kinematic state
uint8 KINEMATICSTATE_RELATIVE = 0
uint8 KINEMATICSTATE_ABSOLUTE = 1
uint8 KINEMATICSTATE_RELATIVE_AND_ABSOLUTE = 2

uint8 KinematicState
"""
  __slots__ = ['Header','CurrentYawAngle','EgoVelocity','EgoYawRate','NofUsedObjects','RadarObjectArray','ExternalSensorID','KinematicState']
  _slot_types = ['rds_conti_radar_object_list_msgs/SensorMsgHeader','float32','float32','float32','uint32','rds_conti_radar_object_list_msgs/RadarObject[]','uint32','rds_conti_radar_object_list_msgs/ObjProvidedKinematicStates']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       Header,CurrentYawAngle,EgoVelocity,EgoYawRate,NofUsedObjects,RadarObjectArray,ExternalSensorID,KinematicState

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RadarObjectList, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.Header is None:
        self.Header = rds_conti_radar_object_list_msgs.msg.SensorMsgHeader()
      if self.CurrentYawAngle is None:
        self.CurrentYawAngle = 0.
      if self.EgoVelocity is None:
        self.EgoVelocity = 0.
      if self.EgoYawRate is None:
        self.EgoYawRate = 0.
      if self.NofUsedObjects is None:
        self.NofUsedObjects = 0
      if self.RadarObjectArray is None:
        self.RadarObjectArray = []
      if self.ExternalSensorID is None:
        self.ExternalSensorID = 0
      if self.KinematicState is None:
        self.KinematicState = rds_conti_radar_object_list_msgs.msg.ObjProvidedKinematicStates()
    else:
      self.Header = rds_conti_radar_object_list_msgs.msg.SensorMsgHeader()
      self.CurrentYawAngle = 0.
      self.EgoVelocity = 0.
      self.EgoYawRate = 0.
      self.NofUsedObjects = 0
      self.RadarObjectArray = []
      self.ExternalSensorID = 0
      self.KinematicState = rds_conti_radar_object_list_msgs.msg.ObjProvidedKinematicStates()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I2BIB3fI().pack(_x.Header.CommonHeader.Seq, _x.Header.CommonHeader.stamp.Sec, _x.Header.CommonHeader.stamp.Nsec, _x.Header.CommonHeader.Timestamp_source.TimeStampSource, _x.Header.CommonHeader.TimeStamp_sync_state.TimeStampSyncState, _x.Header.SensorId, _x.Header.SignalStatus.SignalStatus, _x.CurrentYawAngle, _x.EgoVelocity, _x.EgoYawRate, _x.NofUsedObjects))
      length = len(self.RadarObjectArray)
      buff.write(_struct_I.pack(length))
      for val1 in self.RadarObjectArray:
        _x = val1
        buff.write(_get_struct_2I18f().pack(_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right))
        _v1 = val1.LDeltaQual
        _x = _v1.LDeltaQual
        buff.write(_get_struct_B().pack(_x))
        _x = val1
        buff.write(_get_struct_2fI().pack(_x.RCS, _x.ProbOfExistence, _x.LifeCycles))
        _v2 = val1.DynamicProperty
        _x = _v2.DynamicProperty
        buff.write(_get_struct_B().pack(_x))
        _v3 = val1.ObjState
        _x = _v3.ObjState
        buff.write(_get_struct_B().pack(_x))
        length = len(val1.ObjMeasuredSources)
        buff.write(_struct_I.pack(length))
        pattern = '<%sB'%length
        buff.write(struct.Struct(pattern).pack(*val1.ObjMeasuredSources))
        _x = val1
        buff.write(_get_struct_10f().pack(_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd))
      _x = self
      buff.write(_get_struct_IB().pack(_x.ExternalSensorID, _x.KinematicState.KinematicState))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.Header is None:
        self.Header = rds_conti_radar_object_list_msgs.msg.SensorMsgHeader()
      if self.RadarObjectArray is None:
        self.RadarObjectArray = None
      if self.KinematicState is None:
        self.KinematicState = rds_conti_radar_object_list_msgs.msg.ObjProvidedKinematicStates()
      end = 0
      _x = self
      start = end
      end += 35
      (_x.Header.CommonHeader.Seq, _x.Header.CommonHeader.stamp.Sec, _x.Header.CommonHeader.stamp.Nsec, _x.Header.CommonHeader.Timestamp_source.TimeStampSource, _x.Header.CommonHeader.TimeStamp_sync_state.TimeStampSyncState, _x.Header.SensorId, _x.Header.SignalStatus.SignalStatus, _x.CurrentYawAngle, _x.EgoVelocity, _x.EgoYawRate, _x.NofUsedObjects,) = _get_struct_3I2BIB3fI().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.RadarObjectArray = []
      for i in range(0, length):
        val1 = rds_conti_radar_object_list_msgs.msg.RadarObject()
        _x = val1
        start = end
        end += 80
        (_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right,) = _get_struct_2I18f().unpack(str[start:end])
        _v4 = val1.LDeltaQual
        start = end
        end += 1
        (_v4.LDeltaQual,) = _get_struct_B().unpack(str[start:end])
        _x = val1
        start = end
        end += 12
        (_x.RCS, _x.ProbOfExistence, _x.LifeCycles,) = _get_struct_2fI().unpack(str[start:end])
        _v5 = val1.DynamicProperty
        start = end
        end += 1
        (_v5.DynamicProperty,) = _get_struct_B().unpack(str[start:end])
        _v6 = val1.ObjState
        start = end
        end += 1
        (_v6.ObjState,) = _get_struct_B().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sB'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.ObjMeasuredSources = s.unpack(str[start:end])
        val1.ObjMeasuredSources = list(map(bool, val1.ObjMeasuredSources))
        _x = val1
        start = end
        end += 40
        (_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd,) = _get_struct_10f().unpack(str[start:end])
        self.RadarObjectArray.append(val1)
      _x = self
      start = end
      end += 5
      (_x.ExternalSensorID, _x.KinematicState.KinematicState,) = _get_struct_IB().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I2BIB3fI().pack(_x.Header.CommonHeader.Seq, _x.Header.CommonHeader.stamp.Sec, _x.Header.CommonHeader.stamp.Nsec, _x.Header.CommonHeader.Timestamp_source.TimeStampSource, _x.Header.CommonHeader.TimeStamp_sync_state.TimeStampSyncState, _x.Header.SensorId, _x.Header.SignalStatus.SignalStatus, _x.CurrentYawAngle, _x.EgoVelocity, _x.EgoYawRate, _x.NofUsedObjects))
      length = len(self.RadarObjectArray)
      buff.write(_struct_I.pack(length))
      for val1 in self.RadarObjectArray:
        _x = val1
        buff.write(_get_struct_2I18f().pack(_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right))
        _v7 = val1.LDeltaQual
        _x = _v7.LDeltaQual
        buff.write(_get_struct_B().pack(_x))
        _x = val1
        buff.write(_get_struct_2fI().pack(_x.RCS, _x.ProbOfExistence, _x.LifeCycles))
        _v8 = val1.DynamicProperty
        _x = _v8.DynamicProperty
        buff.write(_get_struct_B().pack(_x))
        _v9 = val1.ObjState
        _x = _v9.ObjState
        buff.write(_get_struct_B().pack(_x))
        length = len(val1.ObjMeasuredSources)
        buff.write(_struct_I.pack(length))
        pattern = '<%sB'%length
        buff.write(val1.ObjMeasuredSources.tostring())
        _x = val1
        buff.write(_get_struct_10f().pack(_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd))
      _x = self
      buff.write(_get_struct_IB().pack(_x.ExternalSensorID, _x.KinematicState.KinematicState))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.Header is None:
        self.Header = rds_conti_radar_object_list_msgs.msg.SensorMsgHeader()
      if self.RadarObjectArray is None:
        self.RadarObjectArray = None
      if self.KinematicState is None:
        self.KinematicState = rds_conti_radar_object_list_msgs.msg.ObjProvidedKinematicStates()
      end = 0
      _x = self
      start = end
      end += 35
      (_x.Header.CommonHeader.Seq, _x.Header.CommonHeader.stamp.Sec, _x.Header.CommonHeader.stamp.Nsec, _x.Header.CommonHeader.Timestamp_source.TimeStampSource, _x.Header.CommonHeader.TimeStamp_sync_state.TimeStampSyncState, _x.Header.SensorId, _x.Header.SignalStatus.SignalStatus, _x.CurrentYawAngle, _x.EgoVelocity, _x.EgoYawRate, _x.NofUsedObjects,) = _get_struct_3I2BIB3fI().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.RadarObjectArray = []
      for i in range(0, length):
        val1 = rds_conti_radar_object_list_msgs.msg.RadarObject()
        _x = val1
        start = end
        end += 80
        (_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right,) = _get_struct_2I18f().unpack(str[start:end])
        _v10 = val1.LDeltaQual
        start = end
        end += 1
        (_v10.LDeltaQual,) = _get_struct_B().unpack(str[start:end])
        _x = val1
        start = end
        end += 12
        (_x.RCS, _x.ProbOfExistence, _x.LifeCycles,) = _get_struct_2fI().unpack(str[start:end])
        _v11 = val1.DynamicProperty
        start = end
        end += 1
        (_v11.DynamicProperty,) = _get_struct_B().unpack(str[start:end])
        _v12 = val1.ObjState
        start = end
        end += 1
        (_v12.ObjState,) = _get_struct_B().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sB'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.ObjMeasuredSources = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
        val1.ObjMeasuredSources = list(map(bool, val1.ObjMeasuredSources))
        _x = val1
        start = end
        end += 40
        (_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd,) = _get_struct_10f().unpack(str[start:end])
        self.RadarObjectArray.append(val1)
      _x = self
      start = end
      end += 5
      (_x.ExternalSensorID, _x.KinematicState.KinematicState,) = _get_struct_IB().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_10f = None
def _get_struct_10f():
    global _struct_10f
    if _struct_10f is None:
        _struct_10f = struct.Struct("<10f")
    return _struct_10f
_struct_2I18f = None
def _get_struct_2I18f():
    global _struct_2I18f
    if _struct_2I18f is None:
        _struct_2I18f = struct.Struct("<2I18f")
    return _struct_2I18f
_struct_2fI = None
def _get_struct_2fI():
    global _struct_2fI
    if _struct_2fI is None:
        _struct_2fI = struct.Struct("<2fI")
    return _struct_2fI
_struct_3I2BIB3fI = None
def _get_struct_3I2BIB3fI():
    global _struct_3I2BIB3fI
    if _struct_3I2BIB3fI is None:
        _struct_3I2BIB3fI = struct.Struct("<3I2BIB3fI")
    return _struct_3I2BIB3fI
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_IB = None
def _get_struct_IB():
    global _struct_IB
    if _struct_IB is None:
        _struct_IB = struct.Struct("<IB")
    return _struct_IB
