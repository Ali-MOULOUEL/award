// Generated by gencpp from file rds_conti_radar_object_list_msgs/RadarObject.msg
// DO NOT EDIT!


#ifndef RDS_CONTI_RADAR_OBJECT_LIST_MSGS_MESSAGE_RADAROBJECT_H
#define RDS_CONTI_RADAR_OBJECT_LIST_MSGS_MESSAGE_RADAROBJECT_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <rds_conti_radar_object_list_msgs/LDeltaQual.h>
#include <rds_conti_radar_object_list_msgs/DynamicProperty.h>
#include <rds_conti_radar_object_list_msgs/ObjState.h>

namespace rds_conti_radar_object_list_msgs
{
template <class ContainerAllocator>
struct RadarObject_
{
  typedef RadarObject_<ContainerAllocator> Type;

  RadarObject_()
    : ObjId(0)
    , InternalId(0)
    , DistX(0.0)
    , DistY(0.0)
    , VrelX(0.0)
    , VrelY(0.0)
    , ArelX(0.0)
    , ArelY(0.0)
    , DistXStd(0.0)
    , DistYStd(0.0)
    , VrelXStd(0.0)
    , VrelYStd(0.0)
    , ArelXStd(0.0)
    , ArelYStd(0.0)
    , LDeltaX_left(0.0)
    , LDeltaX_mid(0.0)
    , LDeltaX_right(0.0)
    , LDeltaY_left(0.0)
    , LDeltaY_mid(0.0)
    , LDeltaY_right(0.0)
    , LDeltaQual()
    , RCS(0.0)
    , ProbOfExistence(0.0)
    , LifeCycles(0)
    , DynamicProperty()
    , ObjState()
    , ObjMeasuredSources()
    , VabsX(0.0)
    , VabsY(0.0)
    , AabsX(0.0)
    , AabsY(0.0)
    , VabsXStd(0.0)
    , VabsYStd(0.0)
    , AabsXStd(0.0)
    , AabsYStd(0.0)
    , Orientation(0.0)
    , OrientationStd(0.0)  {
    }
  RadarObject_(const ContainerAllocator& _alloc)
    : ObjId(0)
    , InternalId(0)
    , DistX(0.0)
    , DistY(0.0)
    , VrelX(0.0)
    , VrelY(0.0)
    , ArelX(0.0)
    , ArelY(0.0)
    , DistXStd(0.0)
    , DistYStd(0.0)
    , VrelXStd(0.0)
    , VrelYStd(0.0)
    , ArelXStd(0.0)
    , ArelYStd(0.0)
    , LDeltaX_left(0.0)
    , LDeltaX_mid(0.0)
    , LDeltaX_right(0.0)
    , LDeltaY_left(0.0)
    , LDeltaY_mid(0.0)
    , LDeltaY_right(0.0)
    , LDeltaQual(_alloc)
    , RCS(0.0)
    , ProbOfExistence(0.0)
    , LifeCycles(0)
    , DynamicProperty(_alloc)
    , ObjState(_alloc)
    , ObjMeasuredSources(_alloc)
    , VabsX(0.0)
    , VabsY(0.0)
    , AabsX(0.0)
    , AabsY(0.0)
    , VabsXStd(0.0)
    , VabsYStd(0.0)
    , AabsXStd(0.0)
    , AabsYStd(0.0)
    , Orientation(0.0)
    , OrientationStd(0.0)  {
  (void)_alloc;
    }



   typedef uint32_t _ObjId_type;
  _ObjId_type ObjId;

   typedef uint32_t _InternalId_type;
  _InternalId_type InternalId;

   typedef float _DistX_type;
  _DistX_type DistX;

   typedef float _DistY_type;
  _DistY_type DistY;

   typedef float _VrelX_type;
  _VrelX_type VrelX;

   typedef float _VrelY_type;
  _VrelY_type VrelY;

   typedef float _ArelX_type;
  _ArelX_type ArelX;

   typedef float _ArelY_type;
  _ArelY_type ArelY;

   typedef float _DistXStd_type;
  _DistXStd_type DistXStd;

   typedef float _DistYStd_type;
  _DistYStd_type DistYStd;

   typedef float _VrelXStd_type;
  _VrelXStd_type VrelXStd;

   typedef float _VrelYStd_type;
  _VrelYStd_type VrelYStd;

   typedef float _ArelXStd_type;
  _ArelXStd_type ArelXStd;

   typedef float _ArelYStd_type;
  _ArelYStd_type ArelYStd;

   typedef float _LDeltaX_left_type;
  _LDeltaX_left_type LDeltaX_left;

   typedef float _LDeltaX_mid_type;
  _LDeltaX_mid_type LDeltaX_mid;

   typedef float _LDeltaX_right_type;
  _LDeltaX_right_type LDeltaX_right;

   typedef float _LDeltaY_left_type;
  _LDeltaY_left_type LDeltaY_left;

   typedef float _LDeltaY_mid_type;
  _LDeltaY_mid_type LDeltaY_mid;

   typedef float _LDeltaY_right_type;
  _LDeltaY_right_type LDeltaY_right;

   typedef  ::rds_conti_radar_object_list_msgs::LDeltaQual_<ContainerAllocator>  _LDeltaQual_type;
  _LDeltaQual_type LDeltaQual;

   typedef float _RCS_type;
  _RCS_type RCS;

   typedef float _ProbOfExistence_type;
  _ProbOfExistence_type ProbOfExistence;

   typedef uint32_t _LifeCycles_type;
  _LifeCycles_type LifeCycles;

   typedef  ::rds_conti_radar_object_list_msgs::DynamicProperty_<ContainerAllocator>  _DynamicProperty_type;
  _DynamicProperty_type DynamicProperty;

   typedef  ::rds_conti_radar_object_list_msgs::ObjState_<ContainerAllocator>  _ObjState_type;
  _ObjState_type ObjState;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _ObjMeasuredSources_type;
  _ObjMeasuredSources_type ObjMeasuredSources;

   typedef float _VabsX_type;
  _VabsX_type VabsX;

   typedef float _VabsY_type;
  _VabsY_type VabsY;

   typedef float _AabsX_type;
  _AabsX_type AabsX;

   typedef float _AabsY_type;
  _AabsY_type AabsY;

   typedef float _VabsXStd_type;
  _VabsXStd_type VabsXStd;

   typedef float _VabsYStd_type;
  _VabsYStd_type VabsYStd;

   typedef float _AabsXStd_type;
  _AabsXStd_type AabsXStd;

   typedef float _AabsYStd_type;
  _AabsYStd_type AabsYStd;

   typedef float _Orientation_type;
  _Orientation_type Orientation;

   typedef float _OrientationStd_type;
  _OrientationStd_type OrientationStd;





  typedef boost::shared_ptr< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> const> ConstPtr;

}; // struct RadarObject_

typedef ::rds_conti_radar_object_list_msgs::RadarObject_<std::allocator<void> > RadarObject;

typedef boost::shared_ptr< ::rds_conti_radar_object_list_msgs::RadarObject > RadarObjectPtr;
typedef boost::shared_ptr< ::rds_conti_radar_object_list_msgs::RadarObject const> RadarObjectConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator1> & lhs, const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator2> & rhs)
{
  return lhs.ObjId == rhs.ObjId &&
    lhs.InternalId == rhs.InternalId &&
    lhs.DistX == rhs.DistX &&
    lhs.DistY == rhs.DistY &&
    lhs.VrelX == rhs.VrelX &&
    lhs.VrelY == rhs.VrelY &&
    lhs.ArelX == rhs.ArelX &&
    lhs.ArelY == rhs.ArelY &&
    lhs.DistXStd == rhs.DistXStd &&
    lhs.DistYStd == rhs.DistYStd &&
    lhs.VrelXStd == rhs.VrelXStd &&
    lhs.VrelYStd == rhs.VrelYStd &&
    lhs.ArelXStd == rhs.ArelXStd &&
    lhs.ArelYStd == rhs.ArelYStd &&
    lhs.LDeltaX_left == rhs.LDeltaX_left &&
    lhs.LDeltaX_mid == rhs.LDeltaX_mid &&
    lhs.LDeltaX_right == rhs.LDeltaX_right &&
    lhs.LDeltaY_left == rhs.LDeltaY_left &&
    lhs.LDeltaY_mid == rhs.LDeltaY_mid &&
    lhs.LDeltaY_right == rhs.LDeltaY_right &&
    lhs.LDeltaQual == rhs.LDeltaQual &&
    lhs.RCS == rhs.RCS &&
    lhs.ProbOfExistence == rhs.ProbOfExistence &&
    lhs.LifeCycles == rhs.LifeCycles &&
    lhs.DynamicProperty == rhs.DynamicProperty &&
    lhs.ObjState == rhs.ObjState &&
    lhs.ObjMeasuredSources == rhs.ObjMeasuredSources &&
    lhs.VabsX == rhs.VabsX &&
    lhs.VabsY == rhs.VabsY &&
    lhs.AabsX == rhs.AabsX &&
    lhs.AabsY == rhs.AabsY &&
    lhs.VabsXStd == rhs.VabsXStd &&
    lhs.VabsYStd == rhs.VabsYStd &&
    lhs.AabsXStd == rhs.AabsXStd &&
    lhs.AabsYStd == rhs.AabsYStd &&
    lhs.Orientation == rhs.Orientation &&
    lhs.OrientationStd == rhs.OrientationStd;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator1> & lhs, const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rds_conti_radar_object_list_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0dc10eaa39f2fdbe9b9bb01a0ae55d98";
  }

  static const char* value(const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0dc10eaa39f2fdbeULL;
  static const uint64_t static_value2 = 0x9b9bb01a0ae55d98ULL;
};

template<class ContainerAllocator>
struct DataType< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rds_conti_radar_object_list_msgs/RadarObject";
  }

  static const char* value(const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#RadarObject fields\n"
"uint32 ObjId                #object ID\n"
"uint32 InternalId           #object ID in internal object list\n"
"float32 DistX               #x-position in Carthesian object coordiante [m], range -200;200\n"
"float32 DistY               #y-position in Carthesian object coordiante [m], range -200;200\n"
"float32 VrelX               #relative velocity in x-direction [m/s], range -400;400\n"
"float32 VrelY               #relative velocity in y-direction [m/s], range -400;400\n"
"float32 ArelX               #relative acceleration in x-direction [m/s²], range -50;50\n"
"float32 ArelY               #relative acceleration in y-direction [m/s²], range -50;50\n"
"float32 DistXStd            #standard deviation of x-position [m], range 0;30\n"
"float32 DistYStd            #standard deviation of y-position [m], range 0;30\n"
"float32 VrelXStd            #standard deviation of relative velocity in x-direction [m/s], range 0;30\n"
"float32 VrelYStd            #standard deviation of relative velocity in y-direction [m/s], range 0;30\n"
"float32 ArelXStd            #standard deviation of relative acceleration in x-direction [m/s²], range 0;30\n"
"float32 ArelYStd            #standard deviation of relative acceleration in y-direction [m/s²], range 0;30\n"
"float32 LDeltaX_left        #x-distance between reference point and bounding box (left, mid, right) [m], range -50;50\n"
"float32 LDeltaX_mid\n"
"float32 LDeltaX_right\n"
"float32 LDeltaY_left        #y-distance between reference point and bounding box (left, mid, right) [m], range -50;50\n"
"float32 LDeltaY_mid\n"
"float32 LDeltaY_right\n"
"LDeltaQual LDeltaQual\n"
"float32 RCS                 #object RCS [dBm²], range -100;100 \n"
"float32 ProbOfExistence     #probability of existance, range 0;1\n"
"uint32 LifeCycles           #number of life cycles, range 0;65534\n"
"DynamicProperty DynamicProperty\n"
"ObjState ObjState\n"
"bool[] ObjMeasuredSources     #statement about which sensor has perceived/measured an object in the current cycle (bitfield: first bit corresponds to sensor 1, etc...): is true if object is perceived by the corresponding sensor\n"
"float32 VabsX               #absolute velocity in x-direction [m/s]\n"
"float32 VabsY               #absolute velocity in y-direction [m/s]\n"
"float32 AabsX               #absolute acceleration in x-direction [m/s²], range -50;50\n"
"float32 AabsY               #absolute acceleration in y-direction [m/s²], range -50;50\n"
"float32 VabsXStd            #standard deviation of absolute velocity in x-direction [m/s], range 0;30\n"
"float32 VabsYStd            #standard deviation of absolute velocity in y-direction [m/s], range 0;30\n"
"float32 AabsXStd            #standard deviation of absolute acceleration in x-direction [m/s²], range 0;30\n"
"float32 AabsYStd            #standard deviation of absolute acceleration in y-direction [m/s²], range 0;30\n"
"float32 Orientation         #relative orientation [rad] between target and ego, CCW positive\n"
"float32 OrientationStd      #standard deviation of relative orientation [rad] between target and ego, CCW positive\n"
"\n"
"\n"
"\n"
"\n"
"================================================================================\n"
"MSG: rds_conti_radar_object_list_msgs/LDeltaQual\n"
"#RadarObject LDeltaQual field : Quality of OBB distances\n"
"uint8 LDELTAQUAL_ALL_INVALID = 0\n"
"uint8 LDELTAQUAL_LEFT_VALID =1\n"
"uint8 LDELTAQUAL_MID_VALID = 2\n"
"uint8 LDELTAQUAL_LEFT_MID_VALID = 3\n"
"uint8 LDELTAQUAL_RIGHT_VALID = 4\n"
"uint8 LDELTAQUAL_RIGHT_LEFT_VALID = 5\n"
"uint8 LDELTAQUAL_RIGHT_MID_VALID = 6\n"
"uint8 LDELTAQUAL_ALL_VALID = 7\n"
"\n"
"uint8 LDeltaQual\n"
"================================================================================\n"
"MSG: rds_conti_radar_object_list_msgs/DynamicProperty\n"
"#RadarObject DynamicProperty field\n"
"uint8 DYNAMICPROPERTY_MOVING = 0\n"
"uint8 DYNAMICPROPERTY_STATIONARY = 1\n"
"uint8 DYNAMICPROPERTY_ONCOMING = 2\n"
"uint8 DYNAMICPROPERTY_UNKNOWN = 3\n"
"\n"
"uint8 DynamicProperty\n"
"================================================================================\n"
"MSG: rds_conti_radar_object_list_msgs/ObjState\n"
"#Radarobject ObjState field\n"
"uint8 OBJSTATE_DELETED = 0\n"
"uint8 OBJSTATE_NEW = 1\n"
"uint8 OBJSTATE_MEASURED = 2\n"
"uint8 OBJSTATE_PREDICTED = 3\n"
"\n"
"uint8 ObjState\n"
;
  }

  static const char* value(const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.ObjId);
      stream.next(m.InternalId);
      stream.next(m.DistX);
      stream.next(m.DistY);
      stream.next(m.VrelX);
      stream.next(m.VrelY);
      stream.next(m.ArelX);
      stream.next(m.ArelY);
      stream.next(m.DistXStd);
      stream.next(m.DistYStd);
      stream.next(m.VrelXStd);
      stream.next(m.VrelYStd);
      stream.next(m.ArelXStd);
      stream.next(m.ArelYStd);
      stream.next(m.LDeltaX_left);
      stream.next(m.LDeltaX_mid);
      stream.next(m.LDeltaX_right);
      stream.next(m.LDeltaY_left);
      stream.next(m.LDeltaY_mid);
      stream.next(m.LDeltaY_right);
      stream.next(m.LDeltaQual);
      stream.next(m.RCS);
      stream.next(m.ProbOfExistence);
      stream.next(m.LifeCycles);
      stream.next(m.DynamicProperty);
      stream.next(m.ObjState);
      stream.next(m.ObjMeasuredSources);
      stream.next(m.VabsX);
      stream.next(m.VabsY);
      stream.next(m.AabsX);
      stream.next(m.AabsY);
      stream.next(m.VabsXStd);
      stream.next(m.VabsYStd);
      stream.next(m.AabsXStd);
      stream.next(m.AabsYStd);
      stream.next(m.Orientation);
      stream.next(m.OrientationStd);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RadarObject_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rds_conti_radar_object_list_msgs::RadarObject_<ContainerAllocator>& v)
  {
    s << indent << "ObjId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ObjId);
    s << indent << "InternalId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.InternalId);
    s << indent << "DistX: ";
    Printer<float>::stream(s, indent + "  ", v.DistX);
    s << indent << "DistY: ";
    Printer<float>::stream(s, indent + "  ", v.DistY);
    s << indent << "VrelX: ";
    Printer<float>::stream(s, indent + "  ", v.VrelX);
    s << indent << "VrelY: ";
    Printer<float>::stream(s, indent + "  ", v.VrelY);
    s << indent << "ArelX: ";
    Printer<float>::stream(s, indent + "  ", v.ArelX);
    s << indent << "ArelY: ";
    Printer<float>::stream(s, indent + "  ", v.ArelY);
    s << indent << "DistXStd: ";
    Printer<float>::stream(s, indent + "  ", v.DistXStd);
    s << indent << "DistYStd: ";
    Printer<float>::stream(s, indent + "  ", v.DistYStd);
    s << indent << "VrelXStd: ";
    Printer<float>::stream(s, indent + "  ", v.VrelXStd);
    s << indent << "VrelYStd: ";
    Printer<float>::stream(s, indent + "  ", v.VrelYStd);
    s << indent << "ArelXStd: ";
    Printer<float>::stream(s, indent + "  ", v.ArelXStd);
    s << indent << "ArelYStd: ";
    Printer<float>::stream(s, indent + "  ", v.ArelYStd);
    s << indent << "LDeltaX_left: ";
    Printer<float>::stream(s, indent + "  ", v.LDeltaX_left);
    s << indent << "LDeltaX_mid: ";
    Printer<float>::stream(s, indent + "  ", v.LDeltaX_mid);
    s << indent << "LDeltaX_right: ";
    Printer<float>::stream(s, indent + "  ", v.LDeltaX_right);
    s << indent << "LDeltaY_left: ";
    Printer<float>::stream(s, indent + "  ", v.LDeltaY_left);
    s << indent << "LDeltaY_mid: ";
    Printer<float>::stream(s, indent + "  ", v.LDeltaY_mid);
    s << indent << "LDeltaY_right: ";
    Printer<float>::stream(s, indent + "  ", v.LDeltaY_right);
    s << indent << "LDeltaQual: ";
    s << std::endl;
    Printer< ::rds_conti_radar_object_list_msgs::LDeltaQual_<ContainerAllocator> >::stream(s, indent + "  ", v.LDeltaQual);
    s << indent << "RCS: ";
    Printer<float>::stream(s, indent + "  ", v.RCS);
    s << indent << "ProbOfExistence: ";
    Printer<float>::stream(s, indent + "  ", v.ProbOfExistence);
    s << indent << "LifeCycles: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.LifeCycles);
    s << indent << "DynamicProperty: ";
    s << std::endl;
    Printer< ::rds_conti_radar_object_list_msgs::DynamicProperty_<ContainerAllocator> >::stream(s, indent + "  ", v.DynamicProperty);
    s << indent << "ObjState: ";
    s << std::endl;
    Printer< ::rds_conti_radar_object_list_msgs::ObjState_<ContainerAllocator> >::stream(s, indent + "  ", v.ObjState);
    s << indent << "ObjMeasuredSources[]" << std::endl;
    for (size_t i = 0; i < v.ObjMeasuredSources.size(); ++i)
    {
      s << indent << "  ObjMeasuredSources[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.ObjMeasuredSources[i]);
    }
    s << indent << "VabsX: ";
    Printer<float>::stream(s, indent + "  ", v.VabsX);
    s << indent << "VabsY: ";
    Printer<float>::stream(s, indent + "  ", v.VabsY);
    s << indent << "AabsX: ";
    Printer<float>::stream(s, indent + "  ", v.AabsX);
    s << indent << "AabsY: ";
    Printer<float>::stream(s, indent + "  ", v.AabsY);
    s << indent << "VabsXStd: ";
    Printer<float>::stream(s, indent + "  ", v.VabsXStd);
    s << indent << "VabsYStd: ";
    Printer<float>::stream(s, indent + "  ", v.VabsYStd);
    s << indent << "AabsXStd: ";
    Printer<float>::stream(s, indent + "  ", v.AabsXStd);
    s << indent << "AabsYStd: ";
    Printer<float>::stream(s, indent + "  ", v.AabsYStd);
    s << indent << "Orientation: ";
    Printer<float>::stream(s, indent + "  ", v.Orientation);
    s << indent << "OrientationStd: ";
    Printer<float>::stream(s, indent + "  ", v.OrientationStd);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RDS_CONTI_RADAR_OBJECT_LIST_MSGS_MESSAGE_RADAROBJECT_H
