// Generated by gencpp from file foresight_outputs/Obstacle.msg
// DO NOT EDIT!


#ifndef FORESIGHT_OUTPUTS_MESSAGE_OBSTACLE_H
#define FORESIGHT_OUTPUTS_MESSAGE_OBSTACLE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <foresight_outputs/BoundBox.h>

namespace foresight_outputs
{
template <class ContainerAllocator>
struct Obstacle_
{
  typedef Obstacle_<ContainerAllocator> Type;

  Obstacle_()
    : boundBox()
    , CenterX(0.0)
    , CenterY(0.0)
    , Class()
    , DangerLevel(0.0)
    , Distance(0.0)
    , ID(0.0)
    , OnPath(false)
    , OnRoad(false)
    , PositionX(0.0)
    , PositionY(0.0)
    , PositionZ(0.0)
    , RealHeight(0.0)
    , RealWidth(0.0)
    , RelativeSpeed(0.0)
    , TTC(0.0)  {
    }
  Obstacle_(const ContainerAllocator& _alloc)
    : boundBox(_alloc)
    , CenterX(0.0)
    , CenterY(0.0)
    , Class(_alloc)
    , DangerLevel(0.0)
    , Distance(0.0)
    , ID(0.0)
    , OnPath(false)
    , OnRoad(false)
    , PositionX(0.0)
    , PositionY(0.0)
    , PositionZ(0.0)
    , RealHeight(0.0)
    , RealWidth(0.0)
    , RelativeSpeed(0.0)
    , TTC(0.0)  {
  (void)_alloc;
    }



   typedef  ::foresight_outputs::BoundBox_<ContainerAllocator>  _boundBox_type;
  _boundBox_type boundBox;

   typedef float _CenterX_type;
  _CenterX_type CenterX;

   typedef float _CenterY_type;
  _CenterY_type CenterY;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _Class_type;
  _Class_type Class;

   typedef float _DangerLevel_type;
  _DangerLevel_type DangerLevel;

   typedef float _Distance_type;
  _Distance_type Distance;

   typedef float _ID_type;
  _ID_type ID;

   typedef uint8_t _OnPath_type;
  _OnPath_type OnPath;

   typedef uint8_t _OnRoad_type;
  _OnRoad_type OnRoad;

   typedef float _PositionX_type;
  _PositionX_type PositionX;

   typedef float _PositionY_type;
  _PositionY_type PositionY;

   typedef float _PositionZ_type;
  _PositionZ_type PositionZ;

   typedef float _RealHeight_type;
  _RealHeight_type RealHeight;

   typedef float _RealWidth_type;
  _RealWidth_type RealWidth;

   typedef float _RelativeSpeed_type;
  _RelativeSpeed_type RelativeSpeed;

   typedef float _TTC_type;
  _TTC_type TTC;





  typedef boost::shared_ptr< ::foresight_outputs::Obstacle_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::foresight_outputs::Obstacle_<ContainerAllocator> const> ConstPtr;

}; // struct Obstacle_

typedef ::foresight_outputs::Obstacle_<std::allocator<void> > Obstacle;

typedef boost::shared_ptr< ::foresight_outputs::Obstacle > ObstaclePtr;
typedef boost::shared_ptr< ::foresight_outputs::Obstacle const> ObstacleConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::foresight_outputs::Obstacle_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::foresight_outputs::Obstacle_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::foresight_outputs::Obstacle_<ContainerAllocator1> & lhs, const ::foresight_outputs::Obstacle_<ContainerAllocator2> & rhs)
{
  return lhs.boundBox == rhs.boundBox &&
    lhs.CenterX == rhs.CenterX &&
    lhs.CenterY == rhs.CenterY &&
    lhs.Class == rhs.Class &&
    lhs.DangerLevel == rhs.DangerLevel &&
    lhs.Distance == rhs.Distance &&
    lhs.ID == rhs.ID &&
    lhs.OnPath == rhs.OnPath &&
    lhs.OnRoad == rhs.OnRoad &&
    lhs.PositionX == rhs.PositionX &&
    lhs.PositionY == rhs.PositionY &&
    lhs.PositionZ == rhs.PositionZ &&
    lhs.RealHeight == rhs.RealHeight &&
    lhs.RealWidth == rhs.RealWidth &&
    lhs.RelativeSpeed == rhs.RelativeSpeed &&
    lhs.TTC == rhs.TTC;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::foresight_outputs::Obstacle_<ContainerAllocator1> & lhs, const ::foresight_outputs::Obstacle_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace foresight_outputs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::foresight_outputs::Obstacle_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::foresight_outputs::Obstacle_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::foresight_outputs::Obstacle_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::foresight_outputs::Obstacle_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::foresight_outputs::Obstacle_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::foresight_outputs::Obstacle_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::foresight_outputs::Obstacle_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dd899dae8fd4048bf4873b1549287ed9";
  }

  static const char* value(const ::foresight_outputs::Obstacle_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xdd899dae8fd4048bULL;
  static const uint64_t static_value2 = 0xf4873b1549287ed9ULL;
};

template<class ContainerAllocator>
struct DataType< ::foresight_outputs::Obstacle_<ContainerAllocator> >
{
  static const char* value()
  {
    return "foresight_outputs/Obstacle";
  }

  static const char* value(const ::foresight_outputs::Obstacle_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::foresight_outputs::Obstacle_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#Obstacles field\n"
"BoundBox boundBox\n"
"float32 CenterX\n"
"float32 CenterY\n"
"string Class\n"
"float32 DangerLevel\n"
"float32 Distance\n"
"float32 ID\n"
"bool OnPath\n"
"bool OnRoad\n"
"float32 PositionX\n"
"float32 PositionY\n"
"float32 PositionZ\n"
"float32 RealHeight\n"
"float32 RealWidth \n"
"float32 RelativeSpeed\n"
"float32 TTC\n"
"\n"
"\n"
"\n"
"\n"
" \n"
"================================================================================\n"
"MSG: foresight_outputs/BoundBox\n"
"#BoundBox field\n"
"float32 BottomRightX\n"
"float32 BottomRightY\n"
"float32 TopLeftX\n"
"float32 TopLeftY\n"
;
  }

  static const char* value(const ::foresight_outputs::Obstacle_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::foresight_outputs::Obstacle_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.boundBox);
      stream.next(m.CenterX);
      stream.next(m.CenterY);
      stream.next(m.Class);
      stream.next(m.DangerLevel);
      stream.next(m.Distance);
      stream.next(m.ID);
      stream.next(m.OnPath);
      stream.next(m.OnRoad);
      stream.next(m.PositionX);
      stream.next(m.PositionY);
      stream.next(m.PositionZ);
      stream.next(m.RealHeight);
      stream.next(m.RealWidth);
      stream.next(m.RelativeSpeed);
      stream.next(m.TTC);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Obstacle_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::foresight_outputs::Obstacle_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::foresight_outputs::Obstacle_<ContainerAllocator>& v)
  {
    s << indent << "boundBox: ";
    s << std::endl;
    Printer< ::foresight_outputs::BoundBox_<ContainerAllocator> >::stream(s, indent + "  ", v.boundBox);
    s << indent << "CenterX: ";
    Printer<float>::stream(s, indent + "  ", v.CenterX);
    s << indent << "CenterY: ";
    Printer<float>::stream(s, indent + "  ", v.CenterY);
    s << indent << "Class: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.Class);
    s << indent << "DangerLevel: ";
    Printer<float>::stream(s, indent + "  ", v.DangerLevel);
    s << indent << "Distance: ";
    Printer<float>::stream(s, indent + "  ", v.Distance);
    s << indent << "ID: ";
    Printer<float>::stream(s, indent + "  ", v.ID);
    s << indent << "OnPath: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OnPath);
    s << indent << "OnRoad: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OnRoad);
    s << indent << "PositionX: ";
    Printer<float>::stream(s, indent + "  ", v.PositionX);
    s << indent << "PositionY: ";
    Printer<float>::stream(s, indent + "  ", v.PositionY);
    s << indent << "PositionZ: ";
    Printer<float>::stream(s, indent + "  ", v.PositionZ);
    s << indent << "RealHeight: ";
    Printer<float>::stream(s, indent + "  ", v.RealHeight);
    s << indent << "RealWidth: ";
    Printer<float>::stream(s, indent + "  ", v.RealWidth);
    s << indent << "RelativeSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.RelativeSpeed);
    s << indent << "TTC: ";
    Printer<float>::stream(s, indent + "  ", v.TTC);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FORESIGHT_OUTPUTS_MESSAGE_OBSTACLE_H
