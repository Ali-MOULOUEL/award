# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rds_conti_radar_object_list_msgs/RadarObject.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rds_conti_radar_object_list_msgs.msg

class RadarObject(genpy.Message):
  _md5sum = "0dc10eaa39f2fdbe9b9bb01a0ae55d98"
  _type = "rds_conti_radar_object_list_msgs/RadarObject"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#RadarObject fields
uint32 ObjId                #object ID
uint32 InternalId           #object ID in internal object list
float32 DistX               #x-position in Carthesian object coordiante [m], range -200;200
float32 DistY               #y-position in Carthesian object coordiante [m], range -200;200
float32 VrelX               #relative velocity in x-direction [m/s], range -400;400
float32 VrelY               #relative velocity in y-direction [m/s], range -400;400
float32 ArelX               #relative acceleration in x-direction [m/s²], range -50;50
float32 ArelY               #relative acceleration in y-direction [m/s²], range -50;50
float32 DistXStd            #standard deviation of x-position [m], range 0;30
float32 DistYStd            #standard deviation of y-position [m], range 0;30
float32 VrelXStd            #standard deviation of relative velocity in x-direction [m/s], range 0;30
float32 VrelYStd            #standard deviation of relative velocity in y-direction [m/s], range 0;30
float32 ArelXStd            #standard deviation of relative acceleration in x-direction [m/s²], range 0;30
float32 ArelYStd            #standard deviation of relative acceleration in y-direction [m/s²], range 0;30
float32 LDeltaX_left        #x-distance between reference point and bounding box (left, mid, right) [m], range -50;50
float32 LDeltaX_mid
float32 LDeltaX_right
float32 LDeltaY_left        #y-distance between reference point and bounding box (left, mid, right) [m], range -50;50
float32 LDeltaY_mid
float32 LDeltaY_right
LDeltaQual LDeltaQual
float32 RCS                 #object RCS [dBm²], range -100;100 
float32 ProbOfExistence     #probability of existance, range 0;1
uint32 LifeCycles           #number of life cycles, range 0;65534
DynamicProperty DynamicProperty
ObjState ObjState
bool[] ObjMeasuredSources     #statement about which sensor has perceived/measured an object in the current cycle (bitfield: first bit corresponds to sensor 1, etc...): is true if object is perceived by the corresponding sensor
float32 VabsX               #absolute velocity in x-direction [m/s]
float32 VabsY               #absolute velocity in y-direction [m/s]
float32 AabsX               #absolute acceleration in x-direction [m/s²], range -50;50
float32 AabsY               #absolute acceleration in y-direction [m/s²], range -50;50
float32 VabsXStd            #standard deviation of absolute velocity in x-direction [m/s], range 0;30
float32 VabsYStd            #standard deviation of absolute velocity in y-direction [m/s], range 0;30
float32 AabsXStd            #standard deviation of absolute acceleration in x-direction [m/s²], range 0;30
float32 AabsYStd            #standard deviation of absolute acceleration in y-direction [m/s²], range 0;30
float32 Orientation         #relative orientation [rad] between target and ego, CCW positive
float32 OrientationStd      #standard deviation of relative orientation [rad] between target and ego, CCW positive




================================================================================
MSG: rds_conti_radar_object_list_msgs/LDeltaQual
#RadarObject LDeltaQual field : Quality of OBB distances
uint8 LDELTAQUAL_ALL_INVALID = 0
uint8 LDELTAQUAL_LEFT_VALID =1
uint8 LDELTAQUAL_MID_VALID = 2
uint8 LDELTAQUAL_LEFT_MID_VALID = 3
uint8 LDELTAQUAL_RIGHT_VALID = 4
uint8 LDELTAQUAL_RIGHT_LEFT_VALID = 5
uint8 LDELTAQUAL_RIGHT_MID_VALID = 6
uint8 LDELTAQUAL_ALL_VALID = 7

uint8 LDeltaQual
================================================================================
MSG: rds_conti_radar_object_list_msgs/DynamicProperty
#RadarObject DynamicProperty field
uint8 DYNAMICPROPERTY_MOVING = 0
uint8 DYNAMICPROPERTY_STATIONARY = 1
uint8 DYNAMICPROPERTY_ONCOMING = 2
uint8 DYNAMICPROPERTY_UNKNOWN = 3

uint8 DynamicProperty
================================================================================
MSG: rds_conti_radar_object_list_msgs/ObjState
#Radarobject ObjState field
uint8 OBJSTATE_DELETED = 0
uint8 OBJSTATE_NEW = 1
uint8 OBJSTATE_MEASURED = 2
uint8 OBJSTATE_PREDICTED = 3

uint8 ObjState"""
  __slots__ = ['ObjId','InternalId','DistX','DistY','VrelX','VrelY','ArelX','ArelY','DistXStd','DistYStd','VrelXStd','VrelYStd','ArelXStd','ArelYStd','LDeltaX_left','LDeltaX_mid','LDeltaX_right','LDeltaY_left','LDeltaY_mid','LDeltaY_right','LDeltaQual','RCS','ProbOfExistence','LifeCycles','DynamicProperty','ObjState','ObjMeasuredSources','VabsX','VabsY','AabsX','AabsY','VabsXStd','VabsYStd','AabsXStd','AabsYStd','Orientation','OrientationStd']
  _slot_types = ['uint32','uint32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','rds_conti_radar_object_list_msgs/LDeltaQual','float32','float32','uint32','rds_conti_radar_object_list_msgs/DynamicProperty','rds_conti_radar_object_list_msgs/ObjState','bool[]','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       ObjId,InternalId,DistX,DistY,VrelX,VrelY,ArelX,ArelY,DistXStd,DistYStd,VrelXStd,VrelYStd,ArelXStd,ArelYStd,LDeltaX_left,LDeltaX_mid,LDeltaX_right,LDeltaY_left,LDeltaY_mid,LDeltaY_right,LDeltaQual,RCS,ProbOfExistence,LifeCycles,DynamicProperty,ObjState,ObjMeasuredSources,VabsX,VabsY,AabsX,AabsY,VabsXStd,VabsYStd,AabsXStd,AabsYStd,Orientation,OrientationStd

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RadarObject, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.ObjId is None:
        self.ObjId = 0
      if self.InternalId is None:
        self.InternalId = 0
      if self.DistX is None:
        self.DistX = 0.
      if self.DistY is None:
        self.DistY = 0.
      if self.VrelX is None:
        self.VrelX = 0.
      if self.VrelY is None:
        self.VrelY = 0.
      if self.ArelX is None:
        self.ArelX = 0.
      if self.ArelY is None:
        self.ArelY = 0.
      if self.DistXStd is None:
        self.DistXStd = 0.
      if self.DistYStd is None:
        self.DistYStd = 0.
      if self.VrelXStd is None:
        self.VrelXStd = 0.
      if self.VrelYStd is None:
        self.VrelYStd = 0.
      if self.ArelXStd is None:
        self.ArelXStd = 0.
      if self.ArelYStd is None:
        self.ArelYStd = 0.
      if self.LDeltaX_left is None:
        self.LDeltaX_left = 0.
      if self.LDeltaX_mid is None:
        self.LDeltaX_mid = 0.
      if self.LDeltaX_right is None:
        self.LDeltaX_right = 0.
      if self.LDeltaY_left is None:
        self.LDeltaY_left = 0.
      if self.LDeltaY_mid is None:
        self.LDeltaY_mid = 0.
      if self.LDeltaY_right is None:
        self.LDeltaY_right = 0.
      if self.LDeltaQual is None:
        self.LDeltaQual = rds_conti_radar_object_list_msgs.msg.LDeltaQual()
      if self.RCS is None:
        self.RCS = 0.
      if self.ProbOfExistence is None:
        self.ProbOfExistence = 0.
      if self.LifeCycles is None:
        self.LifeCycles = 0
      if self.DynamicProperty is None:
        self.DynamicProperty = rds_conti_radar_object_list_msgs.msg.DynamicProperty()
      if self.ObjState is None:
        self.ObjState = rds_conti_radar_object_list_msgs.msg.ObjState()
      if self.ObjMeasuredSources is None:
        self.ObjMeasuredSources = []
      if self.VabsX is None:
        self.VabsX = 0.
      if self.VabsY is None:
        self.VabsY = 0.
      if self.AabsX is None:
        self.AabsX = 0.
      if self.AabsY is None:
        self.AabsY = 0.
      if self.VabsXStd is None:
        self.VabsXStd = 0.
      if self.VabsYStd is None:
        self.VabsYStd = 0.
      if self.AabsXStd is None:
        self.AabsXStd = 0.
      if self.AabsYStd is None:
        self.AabsYStd = 0.
      if self.Orientation is None:
        self.Orientation = 0.
      if self.OrientationStd is None:
        self.OrientationStd = 0.
    else:
      self.ObjId = 0
      self.InternalId = 0
      self.DistX = 0.
      self.DistY = 0.
      self.VrelX = 0.
      self.VrelY = 0.
      self.ArelX = 0.
      self.ArelY = 0.
      self.DistXStd = 0.
      self.DistYStd = 0.
      self.VrelXStd = 0.
      self.VrelYStd = 0.
      self.ArelXStd = 0.
      self.ArelYStd = 0.
      self.LDeltaX_left = 0.
      self.LDeltaX_mid = 0.
      self.LDeltaX_right = 0.
      self.LDeltaY_left = 0.
      self.LDeltaY_mid = 0.
      self.LDeltaY_right = 0.
      self.LDeltaQual = rds_conti_radar_object_list_msgs.msg.LDeltaQual()
      self.RCS = 0.
      self.ProbOfExistence = 0.
      self.LifeCycles = 0
      self.DynamicProperty = rds_conti_radar_object_list_msgs.msg.DynamicProperty()
      self.ObjState = rds_conti_radar_object_list_msgs.msg.ObjState()
      self.ObjMeasuredSources = []
      self.VabsX = 0.
      self.VabsY = 0.
      self.AabsX = 0.
      self.AabsY = 0.
      self.VabsXStd = 0.
      self.VabsYStd = 0.
      self.AabsXStd = 0.
      self.AabsYStd = 0.
      self.Orientation = 0.
      self.OrientationStd = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2I18fB2fI2B().pack(_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right, _x.LDeltaQual.LDeltaQual, _x.RCS, _x.ProbOfExistence, _x.LifeCycles, _x.DynamicProperty.DynamicProperty, _x.ObjState.ObjState))
      length = len(self.ObjMeasuredSources)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.ObjMeasuredSources))
      _x = self
      buff.write(_get_struct_10f().pack(_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.LDeltaQual is None:
        self.LDeltaQual = rds_conti_radar_object_list_msgs.msg.LDeltaQual()
      if self.DynamicProperty is None:
        self.DynamicProperty = rds_conti_radar_object_list_msgs.msg.DynamicProperty()
      if self.ObjState is None:
        self.ObjState = rds_conti_radar_object_list_msgs.msg.ObjState()
      end = 0
      _x = self
      start = end
      end += 95
      (_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right, _x.LDeltaQual.LDeltaQual, _x.RCS, _x.ProbOfExistence, _x.LifeCycles, _x.DynamicProperty.DynamicProperty, _x.ObjState.ObjState,) = _get_struct_2I18fB2fI2B().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.ObjMeasuredSources = s.unpack(str[start:end])
      self.ObjMeasuredSources = list(map(bool, self.ObjMeasuredSources))
      _x = self
      start = end
      end += 40
      (_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd,) = _get_struct_10f().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2I18fB2fI2B().pack(_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right, _x.LDeltaQual.LDeltaQual, _x.RCS, _x.ProbOfExistence, _x.LifeCycles, _x.DynamicProperty.DynamicProperty, _x.ObjState.ObjState))
      length = len(self.ObjMeasuredSources)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.ObjMeasuredSources.tostring())
      _x = self
      buff.write(_get_struct_10f().pack(_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.LDeltaQual is None:
        self.LDeltaQual = rds_conti_radar_object_list_msgs.msg.LDeltaQual()
      if self.DynamicProperty is None:
        self.DynamicProperty = rds_conti_radar_object_list_msgs.msg.DynamicProperty()
      if self.ObjState is None:
        self.ObjState = rds_conti_radar_object_list_msgs.msg.ObjState()
      end = 0
      _x = self
      start = end
      end += 95
      (_x.ObjId, _x.InternalId, _x.DistX, _x.DistY, _x.VrelX, _x.VrelY, _x.ArelX, _x.ArelY, _x.DistXStd, _x.DistYStd, _x.VrelXStd, _x.VrelYStd, _x.ArelXStd, _x.ArelYStd, _x.LDeltaX_left, _x.LDeltaX_mid, _x.LDeltaX_right, _x.LDeltaY_left, _x.LDeltaY_mid, _x.LDeltaY_right, _x.LDeltaQual.LDeltaQual, _x.RCS, _x.ProbOfExistence, _x.LifeCycles, _x.DynamicProperty.DynamicProperty, _x.ObjState.ObjState,) = _get_struct_2I18fB2fI2B().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.ObjMeasuredSources = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.ObjMeasuredSources = list(map(bool, self.ObjMeasuredSources))
      _x = self
      start = end
      end += 40
      (_x.VabsX, _x.VabsY, _x.AabsX, _x.AabsY, _x.VabsXStd, _x.VabsYStd, _x.AabsXStd, _x.AabsYStd, _x.Orientation, _x.OrientationStd,) = _get_struct_10f().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_10f = None
def _get_struct_10f():
    global _struct_10f
    if _struct_10f is None:
        _struct_10f = struct.Struct("<10f")
    return _struct_10f
_struct_2I18fB2fI2B = None
def _get_struct_2I18fB2fI2B():
    global _struct_2I18fB2fI2B
    if _struct_2I18fB2fI2B is None:
        _struct_2I18fB2fI2B = struct.Struct("<2I18fB2fI2B")
    return _struct_2I18fB2fI2B
